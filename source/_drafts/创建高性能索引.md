---
title: 创建高性能索引
tags:
  - mysql
  - 性能/优化
categories:
  - mysql
---

# 高性能索引 #
----
&emsp;&emsp;首先申明，本文章内容绝大数知识点来自于《高性能mysql》一书，个人只是做一个总结用于以后查看，如果希望全面学习，可以读一下《高性能mysql》，很经典的书。

## 索引类型 ##
-----

### B-Tree索引 ###

&emsp;&emsp;B-Tree 和 B+Tree 的原理此处就不再论述，如果感兴趣，推荐《数据结构与算法分析》这本书。

&emsp;&emsp;假设有如下数据表：
```
    CREATE TABLE People (
        last_name varchar(50) not null,
        first_name varchar(50) not null,
        dob date not null,
        gender enum('m', 'f') not null,
        key(last_name, first_name, dob)
    )
```

&emsp;&emsp;索引对如下的查询有效。

* 全职匹配 
    >select * from People where last_name = 'liu' and first_name = 'lei' and dob = '1994-05-05';
* 匹配最左前缀
    > select * from People where last_name = 'liu';
* 匹配列前缀
    > select * from People where last_name like 'l%'; (注意此处like %l%并不会使用索引，因为MySQL并不能优化为范围查询。)
* 匹配范围值
    > select * from People where last_name between 'liu' and 'wang';
* 精确匹配某一列并范围匹配另外一列
    > select * from People where last_name = 'liu' and first_name like 'l%';
* 只访问索引的查询
    > select last_name from People where last_name = 'liu'; (**覆盖索引**，后边会讲)

&emsp;&emsp;因为索引树中的节点是有序的，所以除了按值查找之外，索引还可以用于ORDER BY 操作（按顺序查找）。

&emsp;&emsp; B-Tree 索引的限制

* 如果不按照索引的最左列开始查找，则无法使用索引。
    > select * from People where first_name = 'lei'; (类似的，last_name like '$i' 也是无法使用索引的)。
* 不能跳过索引中的列。
    > select * from People where last_name = 'liu' and dob = '1994-05-05';(可以使用索引，但是只能使用索引的第一列。)
* 如果查询中的某个列的范围查询，则其右边的所有列都无法使用索引优化查询。
    > select * from People where last_name = 'liu' and first_name like 'l%' and dob = '1994-05-05';(只能使用索引的前两列)

### 哈希索引 ###

&emsp;&emsp;哈希索引（hash index) 基于哈希表实现，只有精确匹配索引所有列的查询才有效。在MySQL中，只有Memory引擎显式支持哈希索引。因为哈希索引的一些限制，我认为哈希索引的使用场景有限，不做过多描述。

&emsp;&emsp;哈希索引的限制：

* 哈希索引只包含哈希值和行指针，不存储字段值，所以不能使用索引中的值来避免读取行。
* 哈希索引数据并不是按照索引值顺序存储的，所以也就无法用于排序。
* 哈希索引也无法支持部分索引列匹配查找。
* 哈希索引只支持等值比较查询，包括 =、in()。也不支持任何范围查询。
* 如果哈希冲突很多的话，一些索引维护的代价会很高。

&emsp;&emsp;InnoDB引擎有一个特殊的功能叫做“自适应哈希索引”

&emsp;&emsp;创建自定义哈希索引。在B-Tree上创建一个伪哈希索引。例如需要存储大量的url，并需要根据url进行搜索查找。如果使用B-Tree来存储url，存储内容就会很大，因为url本身都很长。会有如下查询

    > select id from url where url = "https://www.mysql.com";

&emsp;&emsp;若删除原来列上的索引，新增一个被索引的url_crl列，使用crc32做哈希，就可以使用下面的方式查询。

    > select id from url where url = "https://www.mysql.com" and url_crc=CRC32("https://www.mysql.com");


## 索引的优点 ##

&emsp;&emsp;三大优点

    1. 索引大大减少了服务器需要扫描的数据量。
    2. 索引可以帮助服务器避免排序和临时表。
    3. 索引可以将随机I/O变成顺序I/O。

&emsp;&emsp;三星索引：索引将相关记录放到一起获得一星；如果索引中的数据顺序和查找中的顺序一致则获得一星；如果索引中包含了查询中需要的全部列则获得一星。

## 高性能的索引策略 ##

### 独立的列 ###

&emsp;&emsp;独立的列指索引列不能是表达式的一部分，也不能是函数的参数。

### 前缀索引和索引选择性 ###